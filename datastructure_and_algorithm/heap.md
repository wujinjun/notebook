## 堆

### 堆的定义
1. 堆是树，并且是一个完全二叉树
2. 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值，所以有大顶堆和小顶堆
3. 堆用数组存储，对于下标为n的节点（下标n从1开始，废弃下标0）
   * 左子节点的下标为2*n
   * 右子节点的下标为2n+1
   * 父亲节点的下标为n/2
### 堆的常见操作（堆化操作）
* 以下均为大顶堆
#### 1. 上浮
* 原理
	1. 被上浮的元素和自己的父节点比较，如果子节点大于父节点则交换；
	2. 把较大的孩子节点被上浮元素处理

* 代码 
```cpp
// k是游标节点下标，指向被上浮处理的节点
// N是当前堆中元素个数
void swim(int a[], int k) {
    while(k > 1 && a[k/2] < a[k]) {		//父节点值小于子节点值就交换
        swap(a[k/2], a[k]);   		//上浮交换
        k = k/2;									//设置游标节点下标
    }
}
```
#### 2. 下沉
* 原理
	1. 被下沉的元素和自己的孩子节点比较，与较大值的孩子节点交换；
	2. 把较大的孩子节点被下沉元素处理

* 代码
```cpp
// k是游标节点下标，指向被下沉处理的节点
// N是当前堆中元素个数
void sink(int a[], int k, int N) {
    while(2*k <= N) {   //边界条件：子节点的下标不能超过堆中元素个数
        int son = 2*k;	//暂存子节点的下标
        if (son < N && a[son] < a[son+1])son++; //取较大值的子节点下标
        if (a[k] > a[son]) break;		//边界条件：父节点比两个子节点都大
        else swap(a[k], a[son]);    //下沉交换
        k = son;										//设置游标节点下标
    }
}
```

#### 3. 删除堆顶元素
* 原理
	1. 将堆顶元素和最后一个元素进行交换
	2. 将堆中元素总数-1
	3. 对堆顶元素做下沉操作
* 代码
```cpp
void del_max(int a[], int N) {
    swap(a[0], a[N-1]);		//交换
    N--;
    sink(a, 0, N);
}
```
#### 4. 插入一个新的元素
* 原理
	1. 将堆中元素总数+1
	2. 新元素填充在最后的位置
	3. 堆新元素进行上浮的堆化操作
* 代码
```cpp
void insert(int a[],int val, int N) {
    N++;
    a[N] = val; 
    swim(a, N);
}
```
#### 5. 建堆
* 原理
	从最后一个非叶子节点开始，从后往前扫描，并对扫描到的每个节点进行下沉操作
* 代码
```cpp
//初始化大顶堆
void build_heap(int *arr, int k, int len) {
    //最后一个非叶子节点的下标怎么计算的？是一个证明题，暂且记住是len/2 - 1 (下标从0开始)    len/2 (下标从1开始)
    for(int i = len/2 - 1; i >= 0; i--) {
        sink2(arr, k, i);
    }
}
```

### 堆的应用
#### 0. 堆排O(nlogn)
堆排序的关键两步：
	第一步是建堆
	第二步是依次删除堆顶元素，弹出的元素就是组成新的有序数列
#### 1. 优先级队列问题
思路：每次取堆顶元素，就能保证顺序依次从大到小（或从小到大）。
#### 2. 求 Top K，查找第K大的元素
思路： 建立一个大小为K的小顶堆，遍历数据大小为n的数组，每个被遍历到的元素k与堆顶元素对比，如果元素k比堆顶元素大，则删除堆顶元素，将元素k插入堆中；如果元素k比堆顶元素小则继续遍历；最后，堆顶元素就是第K大的元素
#### 3. 求中位数问题
思路：先对n个数据排序，前半部分建立一个大顶堆，后半部分建立一个小顶堆；
* 如果n为奇数，大顶堆存n/2 + 1个，小顶堆存n/2个，此时中位数就是大顶堆的堆顶元素；
* 如果n为偶数，大顶堆存n/2个，小顶堆存n/2个，此时中位数有两个，分别是大顶堆和小顶堆的堆顶元素
* 插入新元素时，先和大顶堆和小顶堆的堆顶元素比较，该插入哪个堆，如果插入到了小顶堆导致小顶堆存n/2 + 1个，大顶堆存n/2个

#### 4. 堆的最后一个非叶子节点的下标为什么是$\cfrac{n}{2}$？（$\cfrac{n}{2}-1$ for 下标从0开始 ）

初始化堆的时候需要从最后一个非叶子节点开始，从后往前逐个做堆化操作，那么非叶子节点的下标是如何确定的？为啥直接就用了$\cfrac{n}{2} - 1$作为最后一个非叶子节点的下标？

对于完全二叉树来说，下标从$\cfrac{n}{2}+1$到n都是叶子节点;（假设下标从1开始，下标从0开始就是$$\cfrac{n}{2}）

换句话说：完全二叉树最后一个叶子节点的下标是$\cfrac{n}{2}$；（假设下标从1开始，下标从0开始就是$n/2 - 1$）
** 反证法 **

如果$\cfrac{n}{2}+1$是非叶子结点，则其一定存在叶子结点，则其叶子结点下标为$(\cfrac{n}{2}+1)*2=n+2$, 这与数组下标范围相矛盾，所以$\cfrac{n}{2}+1$是叶子结点，同理可证下标$\cfrac{n}{2}+2 $到n的结点也为叶子结点。

** 正向证明： **

**证明**：假设堆有n个节点，n为h层完全二叉树节点数

* 完全二叉树1到h-1层节点的数量总和： $2^0+2^1...+2^{(h-2)}=(2^{(h-1)})-1=\cfrac{(2^h)}{2}-1$-----②

* 如果存储堆的数组下标从0开始，那么最后一个非叶子节点的下标就是$\cfrac{(2^h)}{2}-1$，由于输的高度$h=logn$，即$h^2 = n$带进去算一哈就得到：最后一个非叶子节点的下标为$\cfrac{n}{2} - 1$
* 如果存储堆的数组下标从1开始，那么最后一个非叶子节点的下标就是$\cfrac{(2^h)}{2}$，由于$h=logn$，即$h^2 = n$带进去算一哈就得到：最后一个非叶子节点的下标为$\cfrac{n}{2}$

证毕！
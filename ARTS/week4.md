# ARTS-WEEK4

## Algorithm 

#### [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

方法：没什么特殊方法，读懂题目意思就好做

思路：逐个遍历排除，由于循环对称性，只需要从下标0开始遍历就可以

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        int remain = 0;
        int total = 0;
        int station = 0;
        for (int i = 0; i < n; i++) {
            total += gas[i] - cost[i];	//计算所有加油站加的油减去所有路上消耗的油，用来判断是否返回-1；
            remain += gas[i] - cost [i];	//计算每次走一段路，油箱余量油==加的油减去消耗的油
            if (remain < 0) {		//如果油箱余量油小于0，那么这个加油站肯定不是起点
                station = i+1;	//考察下一个加油站
                remain = 0;     //清空油箱
            }
        }
        return total >= 0 ? station : -1;
    }
};
```


## Share

本周学习了装载和动态链接

#### 装载
* 装载的定义：装载就是把程序的指令和数据装入内存中运行；

* **覆盖装入**和**页映射**是两种典型的动态装载方法；

* 覆盖装入是一种比较古老的装载方法，在虚拟存储出现后几乎被淘汰了，基本原理就是轮番把需要的程序和指令覆盖写入内存，就不多讨论了；

具体来解读一下**“页映射”**的原理，分析一下程序是如何通过页映射装载到内存里的；

##### 页映射承载着程序虚拟空间-->物理内存地址的映射关系
众所周知，程序就是指令和数据的集合，如果要把程序装载到内存中就不免会有一个地址映射的问题，这些指令和数据应该装载到内存的哪个地址呢？物理内存地址不是就那么几个GB，怎么把这么多程序有序的装载到内存中呢？所以可以建立一个概念：“页映射”是进程虚拟地址空间和物理地址空间的中间层。
页映射的具体化就是页表的管理；页表中的表项就是虚拟空间到物理内存的映射关系

##### 进程的建立过程中，通过页映射装载程序只是其中一步
进程的建立过程被精简地总结为三步[1]：
1. 创建一个独立的虚拟地址空间
2. 读取可执行文件头，建立虚拟空间和可执行文件之间的关系
3. 将CPU指令寄存器设置成可执行文件的入口地址，启动运行

* 创建进程的虚拟地址空间时，会创建一个页表，准备用来管理虚拟地址和物理地址的映射关系
* 读取可执行文件头时，建立虚拟空间和可执行文件的映射关系，以便在发生“页错误”时可以去可执行文件中查找所需要的页；
```
关于“页错误”：
读取可执行文件头，只是用可执行文件的头部建立虚拟空间和可执行文件的映射关系，而真正的程序指令和数据都没有装载到内存中；当CPU真正开始运行这个程序时（读取虚拟空间地址来执行），发现虚拟空间的页是空白时，会认为这是一个“页错误”，此时控制权交给操作系统，操作系统会根据空白页的偏移量在可执行文件中找到所缺的页，并从物理内存中分配一个物理页面，建立虚拟地址和物理地址的映射关系；
```
#### 动态链接
##### 为什么要动态链接
1. 内存和磁盘空间有限，如果N个程序都使用同一个静态库，那么使用静态链接就会有N个静态库的副本，非常浪费内存和磁盘空间
2. 方便程序开发和发布，不需要因为小的修订就将整个程序全部链接、发布
3. **动态链接的思想**就是在运行时在进行链接，**动态链接的基本实现**就是利用操作系统的动态链接器在程序装载时把所有需要装载到进程的虚拟空间里

##### 动态链接的基本要点
假如要把文件lib.c编译成一个共享目标文件lib.so就可以执行`gcc -fPIC -shared -o lib.so lib.c`
* `-shared`指示编译器创建一个共享目标文件

* `-fPIC`指示编译器产生**地址无关代码**，使用地址无关代码技术后，当一个模块引用其他模块的指令和数据时，会通过**全局偏移表GOT**来进行访问，模块内引用指令和数据时通过计算偏移量来访问

* 动态链接使用**过程链接表PLT**，实现延迟绑定方法，做到了函数第一次使用到时才进行绑定（符号查找、重定位）的效果，避免加载时进行成千上百实际上并不需要的重定位；使用PLT在第一次解析引用时开销很大，但后续只需要一条指令和一个间接的内存引用；

  

[1]俞甲子, 石凡, 潘爱民. 程序员的自我修养[M]. 电子工业出版社, 2009.

